#+TITLE: Java Web


* 预习

- 下载 Tomcat 服务器，完成安装
- 了解 Tomcat 的目录结构，并学会基本配置
- 将 Tomcat 配置到 eclipse/idea 中
- 了解 Servlet/jsp 的基本概念

* CS vs BS

Client-Server，客户端-服务端:
- 需要安装独立的应用程序
- 开发语言丰富多彩，比如 WinForm/WPF/QT/JavaFx
  + 优点，灵活、强大、可定制性强
  + 缺点，对于开发者来说，开发起来麻烦，开发需要掌握的基本知识太多。
    对于用户来说，必须要下载并安装单独的应用
- 需要网络进行交互 (tcp/ip协议，socket 编程)

Browser-Server，浏览器-服务器:
- 借助浏览器进行更多底层任务的执行
- 为了渲染页面，推出了一套规则，叫 html
- 后来 html 虽然能渲染数据，但不够好看，所以就诞生了 css
- 后来虽然有了 css 的加持，页面好看了，但是页面不会动，也让人觉得不够爽
- 所以，就产生了 JavaScript，官方的称呼为 ECMAScript，简称 ES

Web 的时代就这样来临了。

大前端统一江湖的梦想就诞生了。

* Servlet
** 规范

Servlet3.1 规范 [[https://github.com/waylau/servlet-3.1-specification][中文版]] [[https://jcp.org/en/jsr/detail?id=340][英文版]]

Servlet 规范是 JCP 组织推出的一套，如何使用 Java 进行 Web 编程的规范。
它本身只包含一份概念的 pdf，还有一个包含着基本接口的 Jar 包。

Servlet 规范是对所有人开放的，只要你原因，你就可以按照规范上的规定，自行去设计相关的基于 Java 的 Web 服务器。

其中，比较流行的是:
- Apache Tomcat
- Jetty
- Weblogic
- Websphare
- JBoss

他们是基于 Java 进行 Web 编程的服务器，也可以看做是 Servlet 容器。

** Tomcat 容器

这是 Tomcat 的目录结构，也是常见开源项目的标准目录结构:

[[file:img/scrot_2019-06-26_02-57-48.png]]

** hello-world

WorldServlet.java:

#+DOWNLOADED: c:/Users/ADMINI~1/AppData/Local/Temp/scrot.png @ 2019-07-04 01:01:12
[[file:img/scrot_2019-07-04_01-01-12.png]]

web.xml:

#+DOWNLOADED: c:/Users/ADMINI~1/AppData/Local/Temp/scrot.png @ 2019-07-04 01:01:50
[[file:img/scrot_2019-07-04_01-01-50.png]]

** Servlet
*** 请求流程

请求的地址是:
- http://localhost:8888/w1/zzz.html

Tomcat 拿到地址后，除去 schema://host:port/contextPath，得到:
- ~/zzz.html~

接下来，到 web.xml 中，去匹配这个 url，得到相应的要处理的 Servlet 类:
#+BEGIN_SRC xml
  <servlet-mapping>
    <servlet-name>worldServlet</servlet-name>
    <url-pattern>/zzz.html</url-pattern>
  </servlet-mapping>
#+END_SRC

调用 servlet 里的 service 方法，得到返回的字符串，响应给客户端。

最后，客户端，将获取到的响应字符串，渲染到浏览器里面。

TODO: 自己搜索、整理一下，url-pattern 的匹配机制。

*** Servlet/HttpServlet

如果要使用 Java 提供一个 Web 服务，只需要:
- 写一个类，这个类实现 ~Servlet~ 接口即可。在 Servlet 接口的 service 方法内，处理请求，并返回结果到客户端
- 上述实现的类就是一个 Servlet，然后只需要将其编译并部署到 Servlet 容器里即可。部署的意思是放到 Servlet 容器的指定位置，并配置合适的访问的 url
- 常见的 Servlet 容器是 Tomcat，它不仅具备解析 Servlet 类的功能，还能提供基本的 Web 服务器功能

由上可见，如果提供服务，只需要实现接口。可实际上，我们大多数 Web 服务都是基于 Http 请求的。
HTTP 协议有自己的一些独特规则，比如 http method 等，所以为了能更方便处理基于 HTTP 协议的服务，标准中又提供了一个针对性的 HttpServlet 类。
一般来说，我们创建 Servlet，只需要继承这个类即可。

#+BEGIN_SRC java
  public class MyServlet extends HttpServlet {...}
#+END_SRC

之后，就 *不需要理会 service 方法* 了，而是将相应的逻辑写到对应 http method 的 doGet/doPost/doDelete 等方法中即可。

#+BEGIN_SRC java
  public class MyServlet extends HttpServlet {
      @Override
      doGet(req, resp) {
      }

      @Override
      doPost(req, resp) {
      }
  }
#+END_SRC

*** 配置方式

xml 方式。

注解方式。

** Filter <过滤器>
** Listener <监听器>
** 生命周期
* JSP
** 内置对象

~request/response/application/config/session/out/pageContext~

** JSP 指令

- ~<%@ include file="xxx.jsp" %>~
- ~<%@ taglib prefix="c" uri="xxx.tld" %>~
- ~<%@ page import/errorPage/language/pageEncoding/contentType/... %>~

** JSP 动作元素

~<jsp:include/forward/useBean/setProperty/getProperty...>~

** EL 表达式 (Expression Language)

#+BEGIN_EXAMPLE
  <jsp:setProperty name="box" property="ppp" value="1000"/>

  ${expr}
  ${fn:length("xxxxxx")}

  ${param["username"]}
  ${header["user-agent"]}
#+END_EXAMPLE

** JSTL 标准标签库

jar 包:
: javax.servlet:jstl:1.2

功能:
- 核心标签
- 格式化标签
- SQL/XML 标签
- JSTL 函数

使用例子:
#+BEGIN_SRC html
  <!-- 先自行学习 -->
#+END_SRC

* Cookie/Session

* 其他
** forward/redirect，转发 vs 重定向

转发的语法:
#+BEGIN_SRC java
  request.getRequestDispatcher("/xxx").forward(request, response);
#+END_SRC

重定向的语法:
#+BEGIN_SRC java
  response.sendRedirect("/s/xxx");
#+END_SRC

- 转发(forward)是服务器端的内部行为，是指当前的 servlet 将接下来的任务交给了(即转发给了)另外一个 servlet/jsp 去继续处理
- 客户端是不会察觉到转发的行为的，因为它的进行仅存在于服务端
- 重定向(redirect)是服务器借助 HTTP 请求中的 302 返回码，将接下来要处理任务的 url 通知客户端，并让客户端请求新的 url 从而完成剩下的任务
- 一个请求中，如果有重定向，那么客户端实质上是发送了多个请求。如果追踪 http 的通讯，会发现 30x 的返回
- 转发，会存在刷新重复的问题；重定向不会，因为它只是重新进行最后一个请求，这个请求一般不会带一些 *写* 相关的逻辑


* 文件的上传和下载
* 用户的注册和登录
* 完整的增删改查实现


