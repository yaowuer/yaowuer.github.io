#+TITLE: Java 基础


* 基本类型 (primitive type)

[[file:img/java-types-001.png]]

** byte(1)
** char(2)
** short(2)/int(4)/long(8)
** float(4)/double(8)
** boolean

true/false/&&/||/not

优先级的问题

#+BEGIN_SRC java
  a && b || c && d && e || f

  1 * 2 / 3 + 8 / 2 * 3

  (a && b) || (c && d && e) || f
#+END_SRC

** 其他

#+BEGIN_SRC java
  // 下面哪种写法会报错

  float a1 = 32.5; // 错
  float a2 = 32.5f;
  float a3 = (float)32.5;

  double b1 = 32.5;
  double b2 = (double)32.5;
  double b3 = 32.5f; // 错

  byte c1 = 65;
  char c2 = 65;
  int c3 = 65;
  // 1.对不对 2.如果不对，原因 3. 如果对，结果
  System.out.println(c1 + c2 + c3); // -> 195
  // 思考：什么是隐式转型，它的基本规则是什么？
  System.out.println((int)c1 + (int)c2 + (int)c3); // -> 195
  // + 是在 Java 中存在的唯一的一个重载的运算符 3 + 4 / "3" + "4"
  System.out.println("C1: " + c1 + "  C2: " + c2 + "  C3: " + c3);
  // 优先级的问题
  System.out.println("C1: " + c1 + "  C2: " + c2 + c3);
  System.out.println(c1 + c2 + "  C3: " + c3);
  System.out.println("C1: " + c1 + "  C2: " + (c2 + c3));

  // 对不对？为什么错了？
  short d1 = 23;
  short d2 = d1 + 1;
  // 这种是对的
  short d5 = (short) (d1 + 1);
  // 为什么报错
  short d4 = d1 + (short)1;
  // 这个为什么不会报错？
  short d3 = 23;
  d3 += 1;

  // 浮点数在计算机中的表示
  // 伴随着精度丢失
  // 怎么在 Java 中进行浮点数的精确计算？BigDecimal
  double e1 = 1;
  double e2 = 0.99;
  System.out.println(e1 - e2);
#+END_SRC

* 引用类型
** 数组


#+DOWNLOADED: c:/Users/ADMINI~1/AppData/Local/Temp/scrot.png @ 2019-06-24 03:34:58
[[file:img/arr-01.png]]

#+BEGIN_SRC java
  String na = "xxx";
  String nb = "yyy";

  String[] allof152 = new String[] {
      na, nb
  };


  int[] a1 = new int[9];
  a1[0] = 111;
  a1[2] = 222;
  a1[3] = 333;

  int[] a2 = new int[] { 111, 222, 333, 444, 5555 };
  int[] a3 = { 333, 444, 555, 666 };
#+END_SRC

** 示例

#+BEGIN_SRC java
  String aaaName = "aaa";
  int bbbbScore = 90;
  String aaaWeixin = "110";
  int getStudentScore (String name) {
  }
  int aaaScore = 90;
  String bbbName = "aaa";
  String bbbWeixin = "110";

#+END_SRC

* 集合类

- ArrayList
- Hashset
- HashMap 

* 面向对象编程 (Object-Oritened Program)



#+BEGIN_QUOTE

我们不仅需要自由，我们还需要适当的规矩。

规矩能让人不适，但是，它能让整个世界运转得更有效率。


这也就是 Java 之所以能长盛不衰的重要原因:
- 强硬的规则，面向对象的规则 (class-object)
- 强制的静态类型

#+END_QUOTE


** 封装

** 继承

** 多态
